# Okama Finance Bot - Модульная структура v2.0

## Обзор

Это обновленная версия Okama Finance Bot с модульной архитектурой, оптимизированная для работы с Okama v1.5.0. Бот разбит на специализированные сервисы для лучшей производительности и поддержки.

## Структура файлов

### Основные сервисы
- `okama_service_v2.py` - Главный сервис, координирующий работу всех модулей
- `correlation_service.py` - Анализ корреляции активов
- `frontier_service.py` - Эффективная граница
- `comparison_service.py` - Сравнение активов
- `pension_service.py` - Пенсионные портфели
- `monte_carlo_service.py` - Прогнозирование Монте-Карло
- `allocation_service.py` - Анализ распределения активов

### Основные файлы
- `bot_v2.py` - Обновленная версия бота
- `bot.py` - Оригинальная версия бота
- `okama_service.py` - Оригинальный сервис

## Ключевые улучшения

### 1. Совместимость с Okama v1.5.0
- Использование правильных методов API: `get_cagr()`, `get_cumulative_return()`, `get_sharpe_ratio()`
- Корректная работа с атрибутами: `close_monthly`, `assets_ror`, `drawdowns`
- Поддержка `inflation=True` для избежания ошибок

### 2. Модульная архитектура
- Каждый тип анализа вынесен в отдельный сервис
- Легкое добавление новых функций
- Лучшая производительность и отладка

### 3. Улучшенная обработка ошибок
- Fallback механизмы при недоступности данных
- Информативные сообщения об ошибках
- Graceful degradation функциональности

### 4. Оптимизация для лимитов
- Разбиение больших запросов на части
- Эффективное использование памяти
- Кэширование результатов где возможно

## Использование

### Запуск обновленной версии
```bash
# Активируйте виртуальное окружение
source venv/bin/activate

# Запустите обновленную версию бота
python bot_v2.py
```

### Тестирование отдельных сервисов
```python
from okama_service_v2 import OkamaServiceV2

# Создайте сервис
service = OkamaServiceV2()

# Протестируйте создание портфеля
portfolio = service.create_portfolio(['RGBITR.INDX', 'MCFTR.INDX'])

# Получите метрики производительности
metrics = service.get_portfolio_performance(portfolio)
print(metrics)

# Сгенерируйте корреляционную матрицу
correlation_image = service.generate_correlation_matrix(['RGBITR.INDX', 'MCFTR.INDX'])
```

## Основные команды

### Анализ портфеля
```
/portfolio RGBITR.INDX MCFTR.INDX
```

### Анализ рисков
```
/risk AGG.US SPY.US
```

### Корреляция активов
```
/correlation RGBITR.INDX MCFTR.INDX GC.COMM
```

### Эффективная граница
```
/efficient_frontier RGBITR.INDX MCFTR.INDX
```

### Сравнение активов
```
/compare AGG.US SPY.US GC.COMM
```

### Пенсионный портфель
```
/pension RGBITR.INDX MCFTR.INDX 0.6 0.4 1000000 -50000 year
```

### Прогнозирование Монте-Карло
```
/monte_carlo AGG.US SPY.US 20 100 norm
```

### Анализ распределения
```
/allocation RGBITR.INDX MCFTR.INDX GC.COMM
```

## Тестирование и отладка

### Тест интеграции Okama
```
/test RGBITR.INDX MCFTR.INDX
```

### Тест AI сервиса
```
/testai
```

### Отладка данных портфеля
```
/debug RGBITR.INDX MCFTR.INDX
```

## Технические детали

### Поддерживаемые символы
- Российские индексы: `RGBITR.INDX`, `MCFTR.INDX`
- Американские ETF: `AGG.US`, `SPY.US`
- Товары: `GC.COMM` (золото)
- Валюты: `USD.RUB`, `EUR.USD`

### Метрики производительности
- Total Return (общая доходность)
- Annual Return (годовая доходность)
- Volatility (волатильность)
- Sharpe Ratio (коэффициент Шарпа)
- Sortino Ratio (коэффициент Сортино)
- Max Drawdown (максимальная просадка)
- VaR (95%) (Value at Risk)
- CVaR (95%) (Conditional Value at Risk)

### Распределения для Монте-Карло
- `norm` - нормальное распределение
- `lognorm` - логарифмически нормальное распределение

## Устранение неполадок

### Частые ошибки

1. **"Real Return is not defined"**
   - Решение: Добавьте `inflation=True` при создании портфеля

2. **"No price data found"**
   - Решение: Проверьте правильность символов
   - Используйте поддерживаемые форматы: `.INDX`, `.US`, `.COMM`

3. **"Insufficient data for analysis"**
   - Решение: Убедитесь, что у активов достаточно исторических данных
   - Попробуйте другие символы

### Логи и отладка
- Включите логирование для диагностики
- Используйте команду `/debug` для анализа данных портфеля
- Проверьте доступность API Okama

## Производительность

### Оптимизации
- Кэширование результатов анализа
- Асинхронная обработка запросов
- Эффективное использование памяти matplotlib
- Разбиение больших запросов на части

### Лимиты
- Максимум 10 активов в одном анализе
- Максимум 50 лет для Монте-Карло
- Максимум 1000 сценариев для прогнозирования

## Разработка

### Добавление нового сервиса
1. Создайте новый файл `new_service.py`
2. Реализуйте класс с необходимыми методами
3. Добавьте импорт в `okama_service_v2.py`
4. Инициализируйте сервис в конструкторе
5. Добавьте делегирующие методы

### Структура сервиса
```python
class NewService:
    def __init__(self):
        # Инициализация
        
    def main_method(self, *args):
        # Основная логика
        
    def _helper_method(self, *args):
        # Вспомогательные методы
        
    def _create_error_chart(self, error_message: str) -> bytes:
        # Обработка ошибок
```

## Лицензия

Проект использует те же лицензии, что и оригинальные библиотеки Okama и python-telegram-bot.

## Поддержка

При возникновении проблем:
1. Проверьте логи бота
2. Используйте команды отладки
3. Убедитесь в совместимости версий
4. Проверьте доступность API сервисов
